/**
 * SERVER-SIDE PDF GENERATOR
 *
 * This module provides server-side PDF generation capabilities for Convex actions.
 * It uses the same templates and structure as the client-side generator but works
 * in a Node.js environment.
 */

import type { PDFTemplateData, PDFSection } from './pdf-types';

/**
 * Generate PDF content from template data
 *
 * Note: @react-pdf/renderer works client-side. For server-side PDF generation,
 * we need a different approach. This function generates HTML that can be
 * converted to PDF or returns structured data for client-side PDF generation.
 */
export class ServerPDFGenerator {
  /**
   * Generate PDF-ready HTML from template data
   */
  static generateHTML(data: PDFTemplateData): string {
    const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${this.escapeHtml(data.title)}</title>
  <style>
    @page {
      size: A4;
      margin: 2cm;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      line-height: 1.6;
      color: #1f2937;
      max-width: 21cm;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      margin-bottom: 30px;
      border-bottom: 3px solid ${data.branding?.primaryColor || '#2563eb'};
      padding-bottom: 15px;
    }

    .title {
      font-size: 28px;
      font-weight: bold;
      color: #111827;
      margin: 0 0 10px 0;
    }

    .subtitle {
      font-size: 16px;
      color: #6b7280;
      margin: 0 0 15px 0;
    }

    .metadata {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 30px;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      background: #ffffff;
      page-break-inside: avoid;
    }

    .section-title {
      font-size: 20px;
      font-weight: bold;
      color: #374151;
      margin: 0 0 15px 0;
      border-bottom: 2px solid #d1d5db;
      padding-bottom: 8px;
    }

    .section-content {
      font-size: 14px;
      line-height: 1.8;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }

    th, td {
      padding: 12px;
      text-align: left;
      border: 1px solid #e5e7eb;
    }

    th {
      background-color: #f9fafb;
      font-weight: 600;
      color: #374151;
    }

    tr:nth-child(even) {
      background-color: #f9fafb;
    }

    ul {
      list-style-type: disc;
      padding-left: 25px;
    }

    li {
      margin-bottom: 8px;
    }

    .metrics-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin: 20px 0;
    }

    .metric-card {
      padding: 15px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
    }

    .metric-title {
      font-size: 12px;
      color: #64748b;
      margin-bottom: 5px;
    }

    .metric-value {
      font-size: 24px;
      font-weight: bold;
      color: #1e293b;
      margin-bottom: 5px;
    }

    .metric-change {
      font-size: 13px;
    }

    .metric-change.positive {
      color: #059669;
    }

    .metric-change.negative {
      color: #dc2626;
    }

    .metric-change.neutral {
      color: #6b7280;
    }

    .footer {
      margin-top: 50px;
      padding-top: 20px;
      border-top: 1px solid #e5e7eb;
      text-align: center;
      font-size: 11px;
      color: #9ca3af;
    }

    .chart-placeholder {
      height: 250px;
      background: #f3f4f6;
      border: 1px dashed #d1d5db;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #6b7280;
      margin: 15px 0;
    }

    @media print {
      body {
        padding: 0;
      }

      .section {
        border: 1px solid #e5e7eb;
        page-break-inside: avoid;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <div class="header">
    <h1 class="title">${this.escapeHtml(data.title)}</h1>
    ${data.subtitle ? `<p class="subtitle">${this.escapeHtml(data.subtitle)}</p>` : ''}
  </div>

  <!-- Metadata -->
  <div class="metadata">
    <div>Generated: ${data.generatedAt.toLocaleString()}</div>
    <div>User: ${this.escapeHtml(data.userInfo.name)} (${this.escapeHtml(data.userInfo.role)})</div>
  </div>

  <!-- Content Sections -->
  ${this.renderSections(data.content.sections)}

  <!-- Metrics Section -->
  ${this.renderMetrics(data.content.metrics)}

  <!-- Footer -->
  <div class="footer">
    ${this.escapeHtml(data.branding?.footer || `Generated by ${data.branding?.companyName || 'EcoSprout'}`)}
  </div>
</body>
</html>
    `;

    return html;
  }

  /**
   * Render sections HTML
   */
  private static renderSections(sections: PDFSection[]): string {
    return sections
      .sort((a, b) => a.order - b.order)
      .map(section => `
        <div class="section">
          <h2 class="section-title">${this.escapeHtml(section.title)}</h2>
          <div class="section-content">
            ${this.renderSectionContent(section)}
          </div>
        </div>
      `)
      .join('\n');
  }

  /**
   * Render section content based on type
   */
  private static renderSectionContent(section: PDFSection): string {
    switch (section.type) {
      case 'text':
        return `<p>${this.escapeHtml(section.data).replace(/\n/g, '<br>')}</p>`;

      case 'table':
        return this.renderTable(section.data);

      case 'list':
        return `
          <ul>
            ${section.data.map((item: string) => `<li>${this.escapeHtml(item)}</li>`).join('\n')}
          </ul>
        `;

      case 'chart':
        return `
          <div class="chart-placeholder">
            <strong>${this.escapeHtml(section.data.title || 'Chart')}</strong>
            <div>Type: ${this.escapeHtml(section.data.type || 'N/A')}</div>
            <div style="margin-top: 10px; font-size: 12px;">(Chart visualization would be rendered here)</div>
          </div>
        `;

      default:
        return `<pre>${this.escapeHtml(JSON.stringify(section.data, null, 2))}</pre>`;
    }
  }

  /**
   * Render table HTML
   */
  private static renderTable(tableData: { headers: string[]; rows: string[][] }): string {
    return `
      <table>
        <thead>
          <tr>
            ${tableData.headers.map(header => `<th>${this.escapeHtml(header)}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
          ${tableData.rows.map(row => `
            <tr>
              ${row.map(cell => `<td>${this.escapeHtml(cell)}</td>`).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
  }

  /**
   * Render metrics grid
   */
  private static renderMetrics(metrics?: any[]): string {
    if (!metrics || metrics.length === 0) return '';

    return `
      <div class="section">
        <h2 class="section-title">Key Metrics</h2>
        <div class="metrics-grid">
          ${metrics.map(metric => this.renderMetricCard(metric)).join('\n')}
        </div>
      </div>
    `;
  }

  /**
   * Render metric card
   */
  private static renderMetricCard(metric: any): string {
    const changeClass = metric.changeType === 'increase' ? 'positive' :
                       metric.changeType === 'decrease' ? 'negative' : 'neutral';

    return `
      <div class="metric-card">
        <div class="metric-title">${this.escapeHtml(metric.name)}</div>
        <div class="metric-value">${this.formatMetricValue(metric.value, metric.format, metric.unit)}</div>
        ${metric.change !== undefined ? `
          <div class="metric-change ${changeClass}">
            ${metric.change > 0 ? '+' : ''}${metric.change.toFixed(1)}%
          </div>
        ` : ''}
        ${metric.description ? `
          <div style="font-size: 11px; color: #64748b; margin-top: 5px;">
            ${this.escapeHtml(metric.description)}
          </div>
        ` : ''}
      </div>
    `;
  }

  /**
   * Format metric value
   */
  private static formatMetricValue(value: any, format: string, unit: string): string {
    if (typeof value === 'string') return this.escapeHtml(value);

    switch (format) {
      case 'currency':
        return new Intl.NumberFormat('en-US', {
          style: 'currency',
          currency: 'USD',
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
        }).format(value);

      case 'percentage':
        return `${value.toFixed(1)}%`;

      default:
        if (value >= 1000000) {
          return `${(value / 1000000).toFixed(1)}M ${unit}`;
        } else if (value >= 1000) {
          return `${(value / 1000).toFixed(1)}K ${unit}`;
        }
        return `${value.toLocaleString()} ${unit}`;
    }
  }

  /**
   * Escape HTML special characters
   */
  private static escapeHtml(text: string): string {
    const map: { [key: string]: string } = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return String(text).replace(/[&<>"']/g, m => map[m]);
  }

  /**
   * Generate a structured JSON representation suitable for client-side PDF generation
   * This is the preferred approach since @react-pdf/renderer works better client-side
   */
  static generateStructuredData(data: PDFTemplateData): string {
    return JSON.stringify({
      version: '1.0',
      type: 'pdf-template',
      data: data,
      metadata: {
        generatedAt: data.generatedAt.toISOString(),
        generator: 'ServerPDFGenerator',
        format: 'EcoSprout PDF Template v1.0'
      }
    }, null, 2);
  }
}

/**
 * Export helper function for use in Convex actions
 */
export async function generatePDFData(templateData: PDFTemplateData): Promise<{
  html: string;
  json: string;
  size: number;
}> {
  const html = ServerPDFGenerator.generateHTML(templateData);
  const json = ServerPDFGenerator.generateStructuredData(templateData);

  return {
    html,
    json,
    size: html.length + json.length
  };
}
